# Niemals in den c-style mit incrementor-Variable verfallen
# Iteratoren Benutzen!
In [1]: l = [1,2,3,4]

In [2]: for elem in l:
   ...:     print(elem)
   ...:
1
2
3
4

# Falls man einen Counter benötigt.

In [3]: for i, elem in enumerate(l):
   ...:     print('%s: %s' % (i, elem))
   ...:
0: 1
1: 2
2: 3
3: 4

# Wie wird etwas iterierbar?
# Oder... wie mache ich meine Klasse iterierbar?

# Bsp. Stack, bzw. first in last out
In [30]: class Stack(object):
   ....:     def __init__(self):
   ....:         self._internal_stack = []
   ....:     def push(self, value):
   ....:         self._internal_stack.append(value)
   ....:     def pop(self):
   ....:         return self._internal_stack.pop()
   ....:

In [31]: stack = Stack()

In [32]: stack.push(1)

In [33]: stack.push(2)

In [34]: stack.push(3)

In [35]: stack.pop()
Out[35]: 3

In [36]: stack.pop()
Out[36]: 2

In [37]: stack.pop()
Out[37]: 1

In [38]: stack.pop()
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
<ipython-input-38-50ea7ec13fbe> in <module>()
----> 1 stack.pop()

<ipython-input-30-e086572bebe6> in pop(self)
      5         self._internal_stack.append(value)
      6     def pop(self):
----> 7         return self._internal_stack.pop()
      8

IndexError: pop from empty list

# Wie kann automatisch über die Liste gelaufen werden?
# Ziel:
In [39]: for elem in stack:
   ....:     print(elem)

# Ein Iterator muss die Funktion __next__ implementieren
# python3 __next__
# python2 next

In [56]: class Stack(Iterator):
   ....:     def __init__(self):
   ....:         self._internal_stack = []
   ....:     def push(self, value):
   ....:         self._internal_stack.append(value)
   ....:     def pop(self):
   ....:         return self._internal_stack.pop()
   ....:     def __next__(self):
   ....:         if not self._internal_stack:
   ....:             raise StopIteration
   ....:         return self._internal_stack.pop()
   ....:

In [57]: stack = Stack()

In [58]: stack.push(1)

In [59]: stack.push(2)

In [60]: for elem in stack:
   ....:     print(elem)
   ....:
2
1

# Oder man implementiert __iter__
In [34]: del Stack.__next__

In [35]: def __iter__(self):
   ....:     for elem in reversed(self._internal_stack):
   ....:         yield elem
   ....:

In [36]: stack = Stack()

In [37]: Stack.__iter__ = __iter__

In [38]: stack = Stack()

In [39]: stack.push(1)

In [40]: stack.push(2)

In [41]: for elem in stack:
   ....:     print(elem)
   ....:
2
1

# oder, weil reversed schon einen iterator zurück gibt
In [42]: def __iter__(self):
   ....:     return reversed(self._internal_stack)
   ....:

In [43]: Stack.__iter__ = __iter__

In [44]: stack = Stack()

In [45]: stack.push(1)

In [46]: stack.push(2)                                                             

In [47]: for elem in stack:
   ....:     print(elem)
   ....:
2
1

# ab python 3.4 yield from
# um seine intention in code auszudrücken
In [49]: def __iter__(self):
   ....:     yield from reversed(self._internal_stack)
   ....:

In [50]: Stack.__iter__ = __iter__

In [51]: stack = Stack()

In [52]: stack.push(1)

In [53]: stack.push(2)

In [54]: for elem in stack:
   ....:     print(elem)
   ....:
2
1


# Siehe pyhton itertools
# https://docs.python.org/2/library/itertools.html
