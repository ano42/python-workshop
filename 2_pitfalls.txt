## ACHTUNG: intern Zeiger statt neuer Speicher
In [20]: ds = d

In [21]: ds
Out[21]: {'testing': 'foo', 'blah': 'xxx'}

In [22]: ds['some'] = 'more'

In [23]: ds
Out[23]: {'testing': 'foo', 'some': 'more', 'blah': 'xxx'}

In [24]: d
Out[24]: {'testing': 'foo', 'some': 'more', 'blah': 'xxx'}

In [25]: id(d)
Out[25]: 139694086836296

In [26]: id(ds)
Out[26]: 139694086836296

## ... aber für den Fall gibt es copy
In [27]: import copy

In [28]: dn = copy.copy(d)

In [29]: id(dn)
Out[29]: 139694100470728

In [30]: dn['foo'] = 'bar'

In [31]: dn
Out[31]: {'testing': 'foo', 'some': 'more', 'foo': 'bar', 'blah': 'xxx'}

In [32]: d
Out[32]: {'testing': 'foo', 'some': 'more', 'blah': 'xxx'}

## Problem taucht bei Anfängern häufig bei Klassen auf.
## Man kann Properties außerhalb des Konstruktors vordefinieren, sollte
## sich dies aber überlegen.
## ... denn
In [33]: class Foo(object):
   ....:     prop = []
   ....:     def add(self, value):
   ....:         self.prop.append(value)
   ....:

In [34]: foo1 = Foo()

In [35]: foo2 = Foo()

In [36]: foo1.add('Hello')

In [37]: foo2.prop
Out[37]: ['Hello']
## Dieses Verhalten ist nur in den aller seltensten Fällen gewünscht und
## verursacht in den meisten Fällen nur extremen Debugschmerz

## Richtig wäre die Definition im Konstruktor
In [38]: class Foo(object):
   ....:     def __init__(self):
   ....:         self.prop = []
   ....:     def add(self, value):
   ....:         self.prop.append(value)
   ....:

In [39]: foo1 = Foo()

In [40]: foo2 = Foo()

In [41]: foo1.add('Hello')

In [42]: foo2.prop
Out[42]: []

In [43]: foo1.prop
Out[43]: ['Hello']
