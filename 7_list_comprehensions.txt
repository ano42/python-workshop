# List Comprehensions machen die Arbeiten mit Listen einfacher
# Beispiel naiv ohne List Comprehensions
In [1]: l = [1,2,3,4,5]

In [2]: ret = []

In [3]: for elem in l:
   ...:     if elem % 2 == 0:
   ...:         ret.append(elem)
   ...:

In [4]: ret
Out[4]: [2, 4]

## Oder das Selbe als List Comprehension
In [5]: ret = [elem for elem in l if elem % 2 == 0]

In [6]: ret
Out[6]: [2, 4]

## Die Benutzung von List Comprehensions machen den Code oft weniger anfällig
## für Fehler.
## Oft führt die Benutzung auch zu saubererem Code.

In [7]: l = [{'data': 'some data1'},
             {'data': 'some data2'},
             {'data': 'some data3'}]

## Zu jedem Dictionary innerhalb dieser Liste soll ein Feld mit dem Namen
## sequenceno hinzugefügt werden. Resultat soll so aussehen:
## [{'data': 'some data1', 'sequenceno': 1}, ...}

In [18]: l = [{'data': 'some data1'}, {'data': 'some data2'}, {'data': 'some data3'}
]

In [19]: for no, elem in enumerate(l):
   ....:     elem['sequenceno'] = no
   ....:     ret.append(elem)
   ....:

In [20]: ret

Out[17]:
[{'sequenceno': 0, 'data': 'some data1'},
 {'sequenceno': 1, 'data': 'some data2'},
 {'sequenceno': 2, 'data': 'some data3'}]

## Problem hier. Die Manipulation von elem passiert hier mittem im Code-Block
## und ermöglicht keine Wiederverwendbarkeit des Codes.
## Zugegeben, die "Arbeit" im Beispiel ist klein, wird aber bei großen
## zusammengehörenden Blöcken um so wichtiger.

## Im Endeffekt möchte man die Möglichkeit haben, ein Element mit einer
## sequenceno zu versehen. Dieser Code würde sich an beliebigen Stellen
## auf die Struktur ({'data': '...'}) verwenden lassen. Unabhängig davon
## ob das Element gerade aus einer Liste kommt oder nicht.

In [22]: def _add_sequence_no(elem, no):
   ....:     elem['sequenceno'] = no
   ....:     return elem
   ....:

In [23]: ret = _add_sequence_no({'data': 'testing'}, 0)

In [24]: ret
Out[24]: {'sequenceno': 0, 'data': 'testing'}

## _add_sequence_no läßt sich jetzt einfach in einer List Comprehension
## verwenden.

In [25]: l = [{'data': 'some data1'}, {'data': 'some data2'}, {'data': 'some data3'}
]

In [26]: ret = [_add_sequence_no(elem, no) for no, elem in enumerate(l)]

In [27]: ret
Out[27]:
[{'sequenceno': 0, 'data': 'some data1'},
 {'sequenceno': 1, 'data': 'some data2'},
 {'sequenceno': 2, 'data': 'some data3'}]

## VORSICHT... auch hier haben wir wieder das Zeiger-/Speicherbereichproblem

In [28]: l
Out[28]:
[{'sequenceno': 0, 'data': 'some data1'},
 {'sequenceno': 1, 'data': 'some data2'},
 {'sequenceno': 2, 'data': 'some data3'}]

## Die Elemente in der Ausgangsliste wurden ebenfalls verändert, da sie als
## Zeiger in _add_sequence_no geben wird.
## Das Selbe passiert aber auch bei dem naiven Ansatz.
## Hier kann wieder copy verwendet werden um kopien zu erzeugen.

In [30]: import copy

In [31]: def _add_sequence_no(elem, no):
   ....:     new_elem = copy.copy(elem)
   ....:     new_elem['sequenceno'] = no
   ....:     return new_elem
   ....:

n [33]: l = [{'data': 'some data1'}, {'data': 'some data2'}, {'data': 'some data3'}]

In [34]: ret = [_add_sequence_no(elem, no) for no, elem in enumerate(l)]

In [35]: ret
Out[35]:
[{'sequenceno': 0, 'data': 'some data1'},
 {'sequenceno': 1, 'data': 'some data2'},
 {'sequenceno': 2, 'data': 'some data3'}]

In [36]: l
Out[36]: [{'data': 'some data1'}, {'data': 'some data2'}, {'data': 'some data3'}]

## l ist also hier unverändert.


## Möchte man an Stelle von zurückgegebenen Listen lieber mit einem generator
## arbeiten ist dies einfach durch das Benutzen von () möglich.

In [39]: gen = (_add_sequence_no(elem, no) for no, elem in enumerate(l))

In [40]: gen
Out[40]: <generator object <genexpr> at 0x7f3c644cff30>

## Dieser erzeugte Generator kann wie gehabt verwendet werden.
## z.B.

In [41]: next(gen)
Out[41]: {'sequenceno': 0, 'data': 'some data1'}

In [42]: next(gen)
Out[42]: {'sequenceno': 1, 'data': 'some data2'}

In [43]: next(gen)
Out[43]: {'sequenceno': 2, 'data': 'some data3'}

In [44]: next(gen)
---------------------------------------------------------------------------
StopIteration                             Traceback (most recent call last)
<ipython-input-44-8a6233884a6c> in <module>()
----> 1 next(gen)

StopIteration:


## Neben List Comprehensions gibt es zum erzeugen von dictionaries seit
## python 2.7 auch Dict Comprehensions
In [1]: l = ['a', 'b', 'c']

In [2]: d = {v: k for k, v in enumerate(l)}

In [3]: d
Out[3]: {'c': 2, 'a': 0, 'b': 1}

## Muss man auch python 2.6 unterstützen kann man für die selbe Aufgabe auf
## einen Konstruktor von dict zurückgreifen, was auch in python3 noch genau
## so funktioniert.

In [4]: d = dict((v, k) for k, v in enumerate(l))

In [5]: d
Out[5]: {'c': 2, 'a': 0, 'b': 1}
