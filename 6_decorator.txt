## Was ist ein decorator?
## Eine gewöhnliche Funktion, die ein callable (funktion) zurück gibt.

## In python ist alles ein Objekt, auch eine Funktion!
In [1]: def testing(a,b):
   ...:     return a+b
   ...:
In [2]: testing.__class__
Out[2]: function

## Funktionen können also beliebigen Namen (Variablen) zugewiesen werden.
In [3]: mytest = testing

## Hier ist testing _nicht_ ausgeführt worden, sondern nur intern ein
## zusätzlicher Zeiger darauf gesetzt.
In [4]: id(testing)
Out[4]: 47683296

In [5]: id(mytest)
Out[5]: 47683296

## Außerdem kann eine Funktion immer durch eine andere ersetzt werden.
## Am Beispiel einer Methode:
In [6]: class A(object):
   ...:     def test(self, a):
   ...:         return a
   ...:

In [7]: a = A()

In [8]: a.test(1)
Out[8]: 1

In [9]: def replace_test(self, a):
   ...:     return a+1
   ...:

## Die Methode der Klasse wird ersetzt
In [10]: A.test = replace_test

In [11]: a2 = A()

In [12]: a2.test(1)
Out[12]: 2

## Das fertige und bereits benutzte Objekt a bleibt unverändert und gibt
## nach wie vor 1 zurück
In [13]: a.test(1)
Out[13]: 1

## Ziel eines Decorator ist es die Funktion zu ersetzen, die ursprüngliche
## Funktionalität aber beizubehalten.
## Warum sollte man so etwas tun?
## Z.B. soll vor jedem Lauf der eigentlichen Funktion, den Ein- und
## Austritt zu protokollieren.

In [1]: import time

In [2]: def testing(a, b, c=1):
   ...:     time.sleep(c)
   ...:     return a+b
   ...:

## Benötigt wird eine Funktion, die eine Funktion entgegen nimmt und eine
## Funktion zurück gibt.

In [3]: def logit(fn):
   ...:     def _logit(*args, **kw):
   ...:         print("Enter")
   ...:         ret = fn(*args, **kw)
   ...:         print("Leave")
   ...:         return ret
   ...:     return _logit
   ...:

## Die originale Funktion testing ausgeführt.
In [4]: testing(1,2)
Out[4]: 3

## testing ersetzt durch wrap von testing durch logit
## Da logit nur die geschachtelte (closure) Funktion _logit zurück gibt,
## werden weder die prints noch fn (:= testing) aufgeruften.
In [5]: testing = logit(testing)

## testing kann wie gewohnt aufgerufen werden. Es muss kein weiterer Code
## angepasst werden
In [6]: testing(1,2)
Enter
Leave
Out[6]: 3

## In echt ist testing jetzt _logit
In [7]: testing.__name__
Out[7]: '_logit'

## Es gibt die @-Notation um Dekoratoren beim definieren von Funktionen und
## Methoden einfacher zu verwenden:

In [8]: @logit
   ...: def new_func(a, b):
   ...:     time.sleep(1)
   ...:     return a*b
   ...:

In [9]: new_func(1,2)
Enter
Leave
Out[9]: 2

## Dies funktioniert genau so für Methoden:

In [10]: class A(object):
   ....:     @logit
   ....:     def testing(self, x):
   ....:         print('Running testing with x=%s' % x)
   ....:

In [11]: a = A()

In [12]: a.testing(1)
Enter
Running testing with x=1
Leave

## Kann auch als Klasse implementiert werden.
In [17]: class logit(object):
   ....:     def __init__(self, fn):
   ....:         self.fn = fn
   ....:     def __call__(self, *args, **kw):
   ....:         print("class impl Enter")
   ....:         ret = self.fn(*args, **kw)
   ....:         print("class impl Leave")
   ....:         return ret
   ....:

In [18]: @logit
   ....: def another_func(x):
   ....:     print("Running with x=%s" % x)
   ....:     return x
   ....:

In [19]: another_func(1)
class impl Enter
Running with x=1
class impl Leave
Out[19]: 1

## Mehrere Dekoratoren für eine Funktion sind möglich.

In [20]: def timeit(fn):
   ....:     def _timeit(*args, **kw):
   ....:         start = time.time()
   ....:         ret = fn(*args, **kw)
   ....:         end = time.time()
   ....:         print("Runtime: %s" % (end-start))
   ....:         return ret
   ....:     return _timeit
   ....:

In [21]: def yet_another_func(x):
   ....:     time.sleep(1)
   ....:     return x*2
   ....:

In [22]: @logit
   ....: @timeit
   ....: def yet_another_func(x):
   ....:     time.sleep(1)
   ....:     return x*2
   ....:

In [23]: yet_another_func(1)
class impl Enter
Runtime: 1.00109910965
class impl Leave
Out[23]: 2


## Weitere Beispiele für Dekoratoren [1,3]
## Werden in vielen Frameworks für diverse Dinge benutzt.
## z.B. Registrierung von Views in pyramid [4]

>>> from pyramid.view import view_config

>>> @view_config(renderer='templates/foo.pt')
>>> def my_view(request):
...    return {'foo':1, 'bar':2}

## Es wird eine View my_view registriert, die das Template foo.pt benutzt.
## Vom Entwickler muss nur ein Dictionary zurückgegeben werden, dessen Werte
## im Template verwendet werden. Um den Rest kümmert sich das Framework.

## Nachteil von Dekoratoren: Bei Unittests müssen alle Dekoratoren mit
## getestet werden.
## Im pyramid-Beispiel könnte man mit einem naiven Dekorator nicht einfach
## testen ob my_view(some_request) {'foo':1, 'bar':2} zurück gibt, sondern
## ob der gewünschte Response raus kommt.
## Der Author von pyramid Chris McDonough hat zu diesem Zweck venusian [5]
## entwickelt.

## [1] https://wiki.python.org/moin/PythonDecoratorLibrary
## [2] http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps
## [3] http://www.artima.com/weblogs/viewpost.jsp?thread=240808
## [4] https://github.com/Pylons/pyramid/blob/master/pyramid/view.py#L119
## [5] https://github.com/Pylons/venusian
